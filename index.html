<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>胡耶塔 // TERMINAL</title>
    <style>
        body { background: #050505; color: #00ff41; font-family: monospace; display: flex; flex-direction: column; height: 100vh; margin: 0; }
        #chat { flex-grow: 1; padding: 20px; overflow-y: auto; white-space: pre-wrap; border-bottom: 1px solid #00ff41; }
        .controls { padding: 15px; display: flex; gap: 10px; background: #000; }
        input { background: #000; border: 1px solid #00ff41; color: #00ff41; padding: 8px; font-family: inherit; }
        #key { border-color: #ff0055; color: #ff0055; width: 100px; }
        #ms { flex-grow: 1; }
        button { background: #00ff41; color: #000; border: none; padding: 8px 15px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>
    <div id="chat"></div>
    <div class="controls">
        <input type="text" id="nk" placeholder="NICK" style="width: 60px;">
        <input type="password" id="key" placeholder="KEY">
        <input type="text" id="ms" placeholder="MESSAGE..." autocomplete="off">
        <button id="ex">SEND</button>
    </div>

    <script>
        const chat = document.getElementById('chat');
        // ЗАМЕНИ НА СВОЮ ССЫЛКУ RENDER
        const API = window.location.protocol === 'file:' ? 'https://public-chat-4p8s.onrender.com/api' : '/api';
        
        let cacheLines = [];
        const noise = "0123456789ABCDEF%$#@&*";

        // Шифрование (UTF-8)
        function crypt(text, key) {
            if (!key) return text;
            const tBytes = new TextEncoder().encode(text);
            const kBytes = new TextEncoder().encode(key);
            const res = new Uint8Array(tBytes.length);
            for(let i=0; i<tBytes.length; i++) res[i] = tBytes[i] ^ kBytes[i % kBytes.length];
            return btoa(String.fromCharCode(...res));
        }

        // Дешифровка (UTF-8)
        function decrypt(b64, key) {
            try {
                const bytes = new Uint8Array(atob(b64).split("").map(c => c.charCodeAt(0)));
                const kBytes = new TextEncoder().encode(key);
                const res = new Uint8Array(bytes.length);
                for(let i=0; i<bytes.length; i++) res[i] = bytes[i] ^ kBytes[i % kBytes.length];
                return new TextDecoder().decode(res);
            } catch(e) { return "Ошибка ключа"; }
        }

        // Анимация
        function animate(el, user, text) {
            let i = 0;
            const timer = setInterval(() => {
                el.innerText = `${user}: ` + text.split("").map((char, idx) => {
                    if (idx < i) return text[idx];
                    return noise[Math.floor(Math.random() * noise.length)];
                }).join("");
                if (i >= text.length) clearInterval(timer);
                i += 0.5;
            }, 40);
        }

        async function sync() {
            try {
                const res = await fetch(API);
                const data = await res.text();
                const lines = data.split('\n').filter(l => l.trim());
                const key = document.getElementById('key').value;

                lines.forEach((line, idx) => {
                    if (!cacheLines[idx] || cacheLines[idx] !== line) {
                        const div = document.createElement('div');
                        chat.appendChild(div);
                        if (line.includes(": ")) {
                            let [u, p] = [line.split(": ")[0], line.split(": ").slice(1).join(": ")];
                            let dec = decrypt(p, key);
                            animate(div, u, dec);
                        } else { div.innerText = line; }
                        cacheLines[idx] = line;
                        chat.scrollTop = chat.scrollHeight;
                    }
                });
            } catch(e) {}
        }

        async function send() {
            const n = document.getElementById('nk').value || "ANON";
            const k = document.getElementById('key').value;
            const m = document.getElementById('ms').value;
            if (!m) return;

            const payload = crypt(m, k);
            await fetch(API, { method: 'POST', body: `${n}: ${payload}` });
            document.getElementById('ms').value = '';
            sync();
        }

        document.getElementById('ex').onclick = send;
        document.getElementById('ms').onkeypress = (e) => e.key === 'Enter' && send();
        setInterval(sync, 2000);
        sync();
    </script>
</body>
</html>
