<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>胡耶塔 // CHAT</title>
    <style>
        body { background: #000; color: #00ff41; font-family: monospace; }
        #chat { height: 80vh; overflow-y: auto; padding: 20px; border-bottom: 1px solid #00ff41; white-space: pre-wrap; }
        .inputs { padding: 10px; display: flex; gap: 10px; }
        input { background: #000; border: 1px solid #00ff41; color: #00ff41; padding: 5px; }
        #ms { flex-grow: 1; }
        #key { border-color: #ff0055; }
        button { background: #00ff41; color: #000; border: none; cursor: pointer; font-weight: bold; padding: 5px 15px; }
    </style>
</head>
<body>
    <div id="chat"></div>
    <div class="inputs">
        <input type="text" id="nk" placeholder="НИК" style="width: 80px;">
        <input type="password" id="key" placeholder="КЛЮЧ">
        <input type="text" id="ms" placeholder="СООБЩЕНИЕ..." autocomplete="off">
        <button onclick="send()">ОТПРАВИТЬ</button>
    </div>

    <script>
        const chat = document.getElementById('chat');
        // ЗАМЕНИ НА СВОЮ ССЫЛКУ RENDER
        const RENDER_URL = 'https://public-chat-4p8s.onrender.com/api'; 
        const API = window.location.protocol === 'file:' ? RENDER_URL : '/api';

        function crypt(text, key) {
            if (!key) return text;
            let res = "";
            for (let i = 0; i < text.length; i++) {
                res += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
            }
            return res;
        }

        async function sync() {
            try {
                const r = await fetch(API);
                const t = await r.text();
                const key = document.getElementById('key').value;
                const lines = t.split('\n').filter(l => l.trim());
                
                let out = "";
                lines.forEach(line => {
                    if (line.includes(": ")) {
                        let parts = line.split(": ");
                        let user = parts[0];
                        let payload = parts.slice(1).join(": ");
                        try {
                            // Декодируем Base64 -> XOR -> URI-декодирование для кириллицы
                            let raw = crypt(atob(payload), key);
                            out += user + ": " + decodeURIComponent(raw) + "\n";
                        } catch(e) { out += line + "\n"; }
                    } else { out += line + "\n"; }
                });
                chat.innerText = out;
                chat.scrollTop = chat.scrollHeight;
            } catch(e) {}
        }

        async function send() {
            const n = document.getElementById('nk').value || "ANON";
            const k = document.getElementById('key').value;
            const m = document.getElementById('ms').value;
            if (!m) return;

            // Кодируем кириллицу в URI-безопасный вид -> XOR -> Base64
            const safeText = encodeURIComponent(m);
            const encrypted = btoa(crypt(safeText, k));

            await fetch(API, { method: 'POST', body: n + ": " + encrypted });
            document.getElementById('ms').value = "";
            sync();
        }

        setInterval(sync, 2000);
        sync();
    </script>
</body>
</html>
