<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>胡耶塔 // FINAL_NODE</title>
    <style>
        :root { --n: #00ff41; --b: #050505; --r: #ff0055; }
        body { background: var(--b); color: var(--n); font-family: 'Consolas', monospace; display: flex; flex-direction: column; align-items: center; height: 100vh; margin: 0; }
        #chat { width: 95%; max-width: 800px; flex-grow: 1; margin: 10px; padding: 10px; border: 1px solid var(--n); overflow-y: auto; background: rgba(0,20,0,0.2); white-space: pre-wrap; }
        .controls { width: 95%; max-width: 800px; display: flex; gap: 5px; padding-bottom: 10px; }
        input { background: #000; border: 1px solid var(--n); color: var(--n); padding: 8px; outline: none; }
        #key { border-color: var(--r); color: var(--r); width: 100px; }
        #ms { flex-grow: 1; }
        button { background: var(--n); color: #000; border: none; padding: 8px 15px; cursor: pointer; font-weight: bold; }
        .status { width: 95%; max-width: 800px; font-size: 0.7rem; display: flex; justify-content: space-between; }
    </style>
</head>
<body>
    <h2 style="margin: 10px 0;">胡耶塔 // CRYPTO_OS</h2>
    <div class="status"><span id="l">LINK: ???</span><span>UTF-8 XOR ANIMATED</span></div>
    <div id="chat"></div>
    <div class="controls">
        <input type="text" id="nk" placeholder="NICK" style="width: 60px;">
        <input type="password" id="key" placeholder="KEY">
        <input type="text" id="ms" placeholder="MESSAGE..." autocomplete="off">
        <button id="ex">SEND</button>
    </div>

    <script>
        const chat = document.getElementById('chat');
        const l = document.getElementById('l');
        const RENDER_URL = 'https://https://control-u6bq.onrender.com/api'; // ЗАМЕНИ НА СВОЮ
        const API = window.location.protocol === 'file:' ? RENDER_URL : '/api';

        let cache = [];
        const chars = "0123456789ABCDEF!@#$%^&*";

        function crypt(bytes, key) {
            if (!key) return bytes;
            const k = new TextEncoder().encode(key);
            return bytes.map((b, i) => b ^ k[i % k.length]);
        }

        function animate(el, user, text) {
            let iter = 0;
            const int = setInterval(() => {
                el.innerText = `${user}: ` + text.split("").map((c, i) => i < iter ? text[i] : chars[Math.floor(Math.random()*chars.length)]).join("");
                if(iter >= text.length) { clearInterval(int); el.innerText = `${user}: ${text}`; }
                iter += 1/2;
            }, 30);
        }

        async function sync() {
            try {
                const r = await fetch(API);
                const t = await r.text();
                const lines = t.split('\n').filter(x => x.trim());
                const secret = document.getElementById('key').value;

                lines.forEach((line, i) => {
                    if (!cache[i] || cache[i] !== line) {
                        const div = document.createElement('div');
                        chat.appendChild(div);
                        if (line.includes(": ")) {
                            let [u, b64] = [line.split(": ")[0], line.split(": ").slice(1).join(": ")];
                            try {
                                const bytes = new Uint8Array(atob(b64).split("").map(c => c.charCodeAt(0)));
                                const dec = new TextDecoder().decode(crypt(bytes, secret));
                                animate(div, u, dec);
                            } catch(e) { div.innerText = line; }
                        } else { div.innerText = line; }
                        cache[i] = line;
                        chat.scrollTop = chat.scrollHeight;
                    }
                });
                l.innerText = "LINK: OK"; l.style.color = "var(--n)";
            } catch(e) { l.innerText = "LINK: FAIL"; l.style.color = "var(--r)"; }
        }

        async function send() {
            const n = document.getElementById('nk').value || "ANON";
            const m = document.getElementById('ms').value;
            const k = document.getElementById('key').value;
            if (!m) return;

            const bytes = crypt(new TextEncoder().encode(m), k);
            const b64 = btoa(String.fromCharCode(...bytes));
            
            try {
                await fetch(API, { method: 'POST', body: `${n}: ${b64}` });
                document.getElementById('ms').value = '';
                sync();
            } catch(e) { alert("FAIL"); }
        }

        document.getElementById('ex').onclick = send;
        document.getElementById('ms').onkeypress = (e) => e.key === 'Enter' && send();
        setInterval(sync, 2000);
        sync();
    </script>
</body>
</html>
